[user]
	name = Harris Enniss
	email = henniss@transphormusa.com
[alias]
        # All log commands should capture topology clearly, unless
        # indicated otherwise.

        # lg: Show a short summary of recent work.

        # The not condition basically looks for the merge base of the
        # most recent commit to a branch, together with master@{1} (or
        # master@{0} as a fallback)
        #lg = "!git log --graph --oneline --decorate --all --boundary --not $(git merge-base $(git rev-list --branches -n 1) $(git rev-list master@{1} 2> /dev/null || git rev-list master))"

        ver = "!ver(){ git tag -a -m \"$1\" $@; }; ver"
        lg = "!git log --graph --oneline --decorate --all --boundary --not $(git merge-base HEAD master)"
        lgd = "log --graph --decorate --boundary HEAD --not master"

        wlga = "!watch --color git log --graph --decorate --format=short --color"

        # lga: (a)ll. Show entire repo as a graph.
        lga = log --graph --oneline --decorate --all --boundary

        # Smart summary. If we target a child of master, show all
        # branches, excluding parents of master.  If we target
        # something forked from master, only show that branch, and
        # only up to where it merges with master (anything else is too
        # verbose).
        
        lgs = "!lgs() { \
sha=$(git rev-parse --default HEAD $1); \
if [[ $(git rev-list master ^$sha) ]]; then \
    git log --graph --oneline --decorate --boundary $sha --not $(git merge-base master $sha); \
else \
    git log --graph --oneline --decorate --boundary --all $sha --not master; \
fi; \
}; lgs"

        # lgt: (t)opilogical. Show only decorations.
	lgt = log --graph --oneline --decorate --branches --remotes --tags --simplify-by-decoration --boundary

	fpush = push --force-with-lease

	co = checkout
	fixup = commit --fixup
	upush = push --set-upstream origin HEAD

        # Equivalent to checking out target and merging HEAD with it. 
        merge-to = "!gitmergeto() { git push \"`git rev-parse --show-toplevel`\" `git rev-parse --abbrev-ref HEAD`:$1; } && gitmergeto"

        # List branches that can be cleaned up.
        bclean = "!git branch --merged | egrep -v \"(^\\*|development|dev|master)\" "

        # Diff index.
	idiff = diff --cached
        # Diff against merge-base with master. 
        rdiff = "!f(){ sha=$(git rev-parse --default HEAD $1); git diff $(git merge-base master $sha); }; f"

        # Fetch all
        fa = fetch --all

        # Detach.
	off = checkout --detach
        # Delete current branch and detach.
        deleteme = "! branch=$(git rev-parse --abbrev-ref HEAD); git checkout --detach; git branch -D $branch"
        
        amend = "!f(){ git commit --amend $1; }; f"
        
        # List aliases
        la = "!f(){ git config -l | grep -e \"^alias\\.\" | cut -c 7- | sort | grep --color=always -e \"^$1\\S*=\" ; }; f"

[core]
	autocrlf = input
	editor = emacs -Q -nw
[apply]
	whitespace = fix
[rebase]
	autosquash = true
	stat = False
	missingCommitsCheck = warn
[diff]
	algorithm = patience
[merge]
	defaultToUpstream = true
[branch]
	autosetupmerge = true
[rerere]
	enabled = false
[advice]
	detachedHead = false
[fetch]
	prune = true
